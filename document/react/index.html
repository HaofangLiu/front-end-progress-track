<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 知识点 | Lucas文档库</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="compass.svg">
    <meta name="description" content="Lucas document collection">
    
    <link rel="preload" href="/front-end-progress-track/assets/css/0.styles.1c631b42.css" as="style"><link rel="preload" href="/front-end-progress-track/assets/js/app.55fbb09c.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/2.3c044b6f.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/1.946bbbaf.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/28.7910915e.js" as="script"><link rel="prefetch" href="/front-end-progress-track/assets/js/10.100ad0ba.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/11.11c89185.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/12.452422eb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/13.cdbffaeb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/14.29cb1f24.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/15.25a9f6f1.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/16.1008613e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/17.e87875c8.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/18.21caedd4.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/19.261180c5.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/20.35b1a1eb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/21.e78369f6.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/22.67b70316.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/23.f866a84e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/24.6ffc8fb8.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/25.2594d9bd.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/26.3cdec195.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/27.98585499.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/29.a483cbdd.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/3.945872b5.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/30.c84d22d4.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/31.982a1c57.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/32.3c98e77b.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/33.17ee5942.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/34.1e87628b.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/35.6e127866.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/36.5af02e95.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/37.065e5dc3.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/4.e5e6a7bb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/5.d63af971.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/6.489cfffe.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/7.0c7d04fe.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/vendors~docsearch.c632dcce.js">
    <link rel="stylesheet" href="/front-end-progress-track/assets/css/0.styles.1c631b42.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-progress-track/" class="home-link router-link-active"><img src="/front-end-progress-track/compass.svg" alt="Lucas文档库" class="logo"> <span class="site-name can-hide">Lucas文档库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/nodejs/" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/ts/" class="nav-link">
  Typescript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/document/react/.html" class="nav-link">
  Github
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/nodejs/" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/ts/" class="nav-link">
  Typescript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/document/react/.html" class="nav-link">
  Github
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React 知识点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-progress-track/document/react/#严格模式的作用" class="sidebar-link">严格模式的作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#react-和-reactdom-两个包分别有什么作用" class="sidebar-link">React 和 ReactDom 两个包分别有什么作用？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#生命周期有哪些" class="sidebar-link">生命周期有哪些？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#为什么-setsate-有异步更新" class="sidebar-link">为什么 setSate 有异步更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#什么时候是异步更新-什么时候是同步更新" class="sidebar-link">什么时候是异步更新， 什么时候是同步更新</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#列表渲染时为什么加-key" class="sidebar-link">列表渲染时为什么加 key</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#受控组件与非受控组件是什么" class="sidebar-link">受控组件与非受控组件是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#组件间的通信" class="sidebar-link">组件间的通信</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#shouldcomponentupdate-有什么用" class="sidebar-link">shouldComponentUpdate 有什么用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#虚拟-dom-是什么" class="sidebar-link">虚拟 DOM 是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#什么是高阶组件" class="sidebar-link">什么是高阶组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#用过哪些全局状态管理的框架" class="sidebar-link">用过哪些全局状态管理的框架</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#react-router" class="sidebar-link">react router</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#如何实现组件懒加载" class="sidebar-link">如何实现组件懒加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#如何做组件加载过程中统一的-loading" class="sidebar-link">如何做组件加载过程中统一的 Loading</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/react/#hooks" class="sidebar-link">hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#react-hooks-怎么用-useeffect-返回值-依赖值" class="sidebar-link">React Hooks 怎么用？ useEffect 返回值？依赖值？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#useeffect-与-uselayouteffect" class="sidebar-link">useEffect 与 useLayoutEffect</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usememo" class="sidebar-link">useMemo</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usecallback" class="sidebar-link">useCallback</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#useref" class="sidebar-link">useRef</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usecontext" class="sidebar-link">useContext</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usetransition" class="sidebar-link">useTransition</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#并发更新" class="sidebar-link">并发更新</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usedeferredvalue" class="sidebar-link">useDeferredValue</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#usetransition-和-usedeferredvalue-有什么区别" class="sidebar-link">useTransition 和 useDeferredValue 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#useid" class="sidebar-link">useId</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#useimperativehandle" class="sidebar-link">useImperativeHandle</a></li></ul></li><li><a href="/front-end-progress-track/document/react/#next-js" class="sidebar-link">Next.js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#next-js-的数据获取方法" class="sidebar-link">Next.js 的数据获取方法</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#next-js-的路由系统" class="sidebar-link">Next.js 的路由系统</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#app和pages的区别" class="sidebar-link">app和pages的区别</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#next-js-的部署方式" class="sidebar-link">Next.js 的部署方式</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#nextjs-ssr工作原理" class="sidebar-link">Nextjs ssr工作原理</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/react/#hydration原理" class="sidebar-link">hydration原理</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-知识点"><a href="#react-知识点" class="header-anchor">#</a> React 知识点</h1> <h2 id="严格模式的作用"><a href="#严格模式的作用" class="header-anchor">#</a> 严格模式的作用</h2> <ol><li>不安全的生命周期方法：某些生命周期方法在未来的 React 版本中将被弃用。严格模式会警告这些不安全的方法的使用。</li> <li>使用过时或遗留的 API：严格模式会警告使用过时或遗留的 API。</li> <li>意外的副作用：严格模式可以帮助你发现组件中可能的意外副作用。</li> <li>与旧版本 React 不兼容的代码：严格模式会警告你的代码中可能与未来版本的 React 不兼容的部分。</li></ol> <h2 id="react-和-reactdom-两个包分别有什么作用"><a href="#react-和-reactdom-两个包分别有什么作用" class="header-anchor">#</a> React 和 ReactDom 两个包分别有什么作用？</h2> <ol><li>react：这是 React 库的核心。它定义了 React 组件的创建和生命周期方法，以及 React 元素的概念。你可以将其视为 React 的“引擎”。</li> <li>react-dom：这个库提供了在浏览器环境中使用 React 的方法，例如将 React 组件渲染到 DOM 中，或者在 DOM 中触发 React 组件的更新。你可以将其视为 React 的“驱动程序”。</li></ol> <h2 id="生命周期有哪些"><a href="#生命周期有哪些" class="header-anchor">#</a> 生命周期有哪些？</h2> <p><img src="/front-end-progress-track/assets/img/life.06bed6e2.png" alt="life cycle"></p> <ul><li><p>static getDerivedStateFromProps(props, state)</p> <ul><li>如果你定义了 static getDerivedStateFromProps，React 会在初始挂载和后续更新时调用 render 之前调用它。它应该返回一个对象来更新 state，或者返回 null 就不更新任何内容。</li> <li>props：组件即将用来渲染的下一个 props。</li> <li>state：组件即将渲染的下一个 state。</li></ul></li> <li><p>getSnapshotBeforeUpdate(prevProps, prevState)</p> <ul><li>render 以后， 只会在更新的时候执行</li> <li>如果你实现了 getSnapshotBeforeUpdate，React 会在 React 更新 DOM 之前时直接调用它。它使你的组件能够在 DOM 发生更改之前捕获一些信息（例如滚动的位置）。此生命周期方法返回的任何值都将作为参数传递给 componentDidUpdate。</li></ul></li> <li><p>挂载时</p> <ul><li>constructor()</li> <li>render()</li> <li>componentDidmount()</li></ul></li> <li><p>更新</p> <ul><li>componentDidUpdate(prevProps, prevState， snapshot?)</li></ul></li> <li><p>卸载</p> <ul><li>componentWillUnmount()</li></ul></li></ul> <h2 id="为什么-setsate-有异步更新"><a href="#为什么-setsate-有异步更新" class="header-anchor">#</a> 为什么 setSate 有异步更新</h2> <ul><li><p>react 在执行 setState 后需要执行 render， diff， 更新 DOM 等一些列操作， 性能开销是比较大的。 加入异步更新，更新合并等策略能优化性能。</p></li> <li><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。（react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange 这些都是合成事件）</p></li> <li><p>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</p></li> <li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></li></ul> <h2 id="什么时候是异步更新-什么时候是同步更新"><a href="#什么时候是异步更新-什么时候是同步更新" class="header-anchor">#</a> 什么时候是异步更新， 什么时候是同步更新</h2> <ul><li>组件里面的事件处理程序， 比如<code>onClick = {handleClick}</code>里面的 setState 是异步更新， 生命周期函数里面的 setState 是异步更新。</li> <li>其他地方， 比如<code>setTimeout</code> 或者<code>addEventListener</code>都是同步更新。</li></ul> <h2 id="列表渲染时为什么加-key"><a href="#列表渲染时为什么加-key" class="header-anchor">#</a> 列表渲染时为什么加 key</h2> <ul><li>dom diff 的时候用于识别原有的 dom，提升性能</li></ul> <h2 id="受控组件与非受控组件是什么"><a href="#受控组件与非受控组件是什么" class="header-anchor">#</a> 受控组件与非受控组件是什么</h2> <ul><li><code>&lt;FInput value={x} onChange={changeValue} /&gt;</code>受控组件： 由开发者控制状态，value 等</li> <li><code>&lt;FInput defaultValue={x} ref={input} /&gt;</code> 非受控组件： 不由开发者控制的组件</li></ul> <h2 id="组件间的通信"><a href="#组件间的通信" class="header-anchor">#</a> 组件间的通信</h2> <ul><li>父子组件通过 props</li> <li>爷孙组件可以通过 Context， createContext， Provider</li> <li>任意组件可以通过 eventBus</li> <li>更复杂的可以通过 redux， mobx 状态管理库</li></ul> <h2 id="shouldcomponentupdate-有什么用"><a href="#shouldcomponentupdate-有什么用" class="header-anchor">#</a> shouldComponentUpdate 有什么用</h2> <ul><li>用于优化性能，假如不需要更新视图， 则可以返回 false 去不进行这次渲染。</li></ul> <h2 id="虚拟-dom-是什么"><a href="#虚拟-dom-是什么" class="header-anchor">#</a> 虚拟 DOM 是什么</h2> <ul><li>vDom 就是我们写的 JSX， JSX 会返回一个对象包含了属性和孩子的数据对象， 也就是虚拟 DOM。 babel 会把 JSX 变成<code>Reacte.createElement</code>, 数据对象和将来要渲染到页面的 DOM 一一对应。</li></ul> <h1 id="react-的原理是什么"><a href="#react-的原理是什么" class="header-anchor">#</a> React 的原理是什么</h1> <ul><li>babel 把 jsx 变成<code>React.createElement</code> 把 JSX 变成一个包含属性和孩子的数据对象（Vdom，通过 render 方法渲染成真正的 DOM 放在页面上，当 setState 时重新执行 render， 进行 DOM diff， 给旧 DOM 进行“补丁升级”。</li></ul> <h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="header-anchor">#</a> 什么是高阶组件</h2> <ul><li>高阶组件就是一个函数， 接受一个组件作为参数， 并且返回一个新的组件。</li></ul> <h2 id="用过哪些全局状态管理的框架"><a href="#用过哪些全局状态管理的框架" class="header-anchor">#</a> 用过哪些全局状态管理的框架</h2> <ul><li>redux 和 mobx</li></ul> <h2 id="react-router"><a href="#react-router" class="header-anchor">#</a> react router</h2> <ul><li>BrowserRouter/HashRouter</li> <li>Switch 决定渲染什么</li> <li>Route 做匹配</li> <li>Link   跳转</li></ul> <h2 id="如何实现组件懒加载"><a href="#如何实现组件懒加载" class="header-anchor">#</a> 如何实现组件懒加载</h2> <p><code>React.lazy(() =&gt; import('././component.ts'))</code></p> <h2 id="如何做组件加载过程中统一的-loading"><a href="#如何做组件加载过程中统一的-loading" class="header-anchor">#</a> 如何做组件加载过程中统一的 Loading</h2> <p><code>&lt;Suspense fallback={&lt;Loading /&gt;}&gt;&lt;/Suspense&gt;</code></p> <h2 id="hooks"><a href="#hooks" class="header-anchor">#</a> hooks</h2> <h3 id="react-hooks-怎么用-useeffect-返回值-依赖值"><a href="#react-hooks-怎么用-useeffect-返回值-依赖值" class="header-anchor">#</a> React Hooks 怎么用？ useEffect 返回值？依赖值？</h3> <ul><li>useEffect
<ul><li>不设置第二个参数的时候， 监控所有的 state 的变化。相当于 componentDidMount 和 componentDidUpdate</li> <li>返回一个箭头函数的时候， 用于组件卸载时执行。相当于 componentWillUnmount。（组建依赖项更新时也会被调用， 更新的执行， 相当于卸载了。 想切换更新时的例子）</li> <li>第二个参数不为空的时候，表示仅对该 state 进行监控。</li> <li>第二个参数为空数组的时候，相当于 componenntDidMount，仅仅在初始化的时候执行。</li> <li>useState 函数内组件参数。</li></ul></li></ul> <h3 id="useeffect-与-uselayouteffect"><a href="#useeffect-与-uselayouteffect" class="header-anchor">#</a> useEffect 与 useLayoutEffect</h3> <p>React 提供了两个钩子函数来在组件渲染之后触发副作用：useEffect 和 useLayoutEffect。(注意是浏览器渲染以后)</p> <p>useEffect 是一个高阶函数，它接受一个回调函数作为参数，在组件渲染之后调用该回调函数，并且在组件卸载时进行清理工作。</p> <p>useLayoutEffect 与 useEffect 类似，它也接受一个回调函数作为参数，并在组件渲染之后调用该回调函数，并且在组件卸载时进行清理工作。</p> <p>不同之处在于 useLayoutEffect 会在浏览器更新布局之前执行，而 useEffect 会在浏览器更新画面之后执行。</p> <p>这意味着 useLayoutEffect 可以在更新之前访问 DOM 节点的布局信息，而 useEffect 则需要等到浏览器更新画面之后才能访问。</p> <p>因此，useLayoutEffect 通常用来处理需要立即获取 DOM 布局信息或者需要在 DOM 布局更新之前触发操作的场景，比如动画，高度计算等。</p> <p>总结，useEffect 和 useLayoutEffect 都是用来处理副作用，但是 useLayoutEffect 会在浏览器更新布局之前执行，而 useEffect 会在浏览器更新画面之后执行。</p> <h3 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h3> <ul><li><p>它是用于react渲染过程中的性能优化。
适用于： 父组件要进行更新，子组件的重新render计算量比较大，而且结果可以复用。就可以使用useMemo来提升父组件引起子组件不必要渲染的性能优化。
useMemo：返回计算得到的值。</p></li> <li><p>但是不是所有地方都要用。 不得已的时候才会用</p> <ul><li>useMemo本身有性能消耗， 缓存消耗内存， useMemo自身维护也是有性能开销的</li> <li>增加开发成本， 维护困难</li> <li>api可能会被取消</li></ul></li> <li><p>React.memo
可以阻止父组件渲染引起的子组件（组件本身）更新。</p></li></ul> <h3 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h3> <p>对函数引用的缓存
useCallback：返回缓存的函数。</p> <h3 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h3> <ul><li>获取dom实例</li> <li>forwardRef
<ul><li>实际上函数式组件没有ref， 需要用forwardRef转发出去</li></ul></li></ul> <h3 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> useContext</h3> <p>跨组件传值</p> <ul><li>核心是父组件用Provider包裹， 给所有子组件注入上下文</li> <li>子组件通过useContext拿到value</li></ul> <h3 id="usetransition"><a href="#usetransition" class="header-anchor">#</a> useTransition</h3> <ul><li>演示react真正意义比vue厉害的地方（用于性能提升）</li> <li>特性： 并发更新（fiber架构）</li></ul> <h3 id="并发更新"><a href="#并发更新" class="header-anchor">#</a> 并发更新</h3> <ul><li><p>fiber架构 -&gt; 指的是一种数据结构 （深度优先遍历）</p> <ul><li>底层： 三个属性：child parent sibling</li></ul></li> <li><p>分片更新</p></li> <li><p>浏览器的空闲时间</p> <ul><li>react并发更新的作用：
<ul><li>给予fiber数据结构， 进行细粒度的任务拆分</li> <li>在浏览器空闲时间执行， requestIdleCallback的思想。</li> <li>因为requestIdleCallback兼容性不好， 所以目前使用PostMessage去模拟实现的。它是宏任务的异步。</li></ul></li></ul></li></ul> <h3 id="usedeferredvalue"><a href="#usedeferredvalue" class="header-anchor">#</a> useDeferredValue</h3> <ul><li>将任务处理为低优先级的任务</li></ul> <h3 id="usetransition-和-usedeferredvalue-有什么区别"><a href="#usetransition-和-usedeferredvalue-有什么区别" class="header-anchor">#</a> useTransition 和 useDeferredValue 有什么区别？</h3> <ul><li>一般useDeferredValue比较适合组件接收的props参数导致渲染缓慢的优化</li> <li>useTransition 适合在自己组件内部/本身进行优化</li></ul> <h3 id="useid"><a href="#useid" class="header-anchor">#</a> useId</h3> <ul><li><p>react组件渲染过程中生成一个ID</p></li> <li><p>这个ID是根据react组件树的位置相关， 不是随机的， 每次生成都一样</p></li> <li><p>为什么不能用随机数？</p></li> <li><p>因为nodejs做react的服务端渲染时， 需要确保node端生成的id和前端一样</p></li></ul> <h3 id="useimperativehandle"><a href="#useimperativehandle" class="header-anchor">#</a> useImperativeHandle</h3> <ul><li>作用： 自定义转发出去的ref（与ref一起使用的）</li> <li>应用场景： 不希望开发者直接操作dom， 你用我给你提供的方法就好</li></ul> <h2 id="next-js"><a href="#next-js" class="header-anchor">#</a> Next.js</h2> <ul><li>Next.js 是一个基于 React 的服务端渲染框架，提供了许多开箱即用的功能，如路由、数据获取、静态生成等。</li> <li>它的核心特性包括：
<ul><li><strong>文件系统路由</strong>：通过在 pages 目录下创建文件来定义路由。</li> <li><strong>静态生成和服务端渲染</strong>：支持在构建时生成静态页面或在请求时动态渲染页面。</li> <li><strong>API 路由</strong>：可以在 pages/api 目录下创建 API 路由。</li> <li><strong>CSS 和样式支持</strong>：内置对 CSS 和 Sass 的支持。</li> <li><strong>自动代码分割</strong>：每个页面只加载所需的 JavaScript 和 CSS。</li></ul></li></ul> <h3 id="next-js-的数据获取方法"><a href="#next-js-的数据获取方法" class="header-anchor">#</a> Next.js 的数据获取方法</h3> <ul><li><strong>getStaticProps</strong>：在构建时获取数据，适用于静态生成的页面。</li> <li><strong>getServerSideProps</strong>：在每次请求时获取数据，适用于服务端渲染的页面。</li> <li><strong>getStaticPaths</strong>：与 getStaticProps 一起使用，用于生成动态路由的静态页面。</li></ul> <h3 id="next-js-的路由系统"><a href="#next-js-的路由系统" class="header-anchor">#</a> Next.js 的路由系统</h3> <ul><li>Next.js 使用文件系统路由，任何在 pages 目录下的文件都会自动成为一个路由。</li></ul> <h3 id="app和pages的区别"><a href="#app和pages的区别" class="header-anchor">#</a> app和pages的区别</h3> <ul><li><strong>pages</strong>：传统的 Next.js 路由系统，使用 pages 目录来定义路由。</li> <li><strong>app</strong>：新的路由系统，提供更灵活的布局和数据获取方式，支持嵌套路由和更细粒度的页面控制。</li></ul> <h3 id="next-js-的部署方式"><a href="#next-js-的部署方式" class="header-anchor">#</a> Next.js 的部署方式</h3> <ul><li>Next.js 应用可以部署到多种平台，如 Vercel、Netlify、AWS 等。它支持静态导出和服务端渲染，可以根据需要选择合适的部署方式。</li></ul> <h3 id="nextjs-ssr工作原理"><a href="#nextjs-ssr工作原理" class="header-anchor">#</a> Nextjs ssr工作原理</h3> <ul><li><p>Next.js 的服务端渲染（SSR）工作原理是，当用户请求一个页面时，Next.js 会在服务器上执行该页面的代码，包括数据获取和组件渲染，然后将生成的 HTML 返回给客户端。这样可以确保页面在加载时就包含了所需的数据，提高了首屏加载速度和 SEO 性能。</p></li> <li><p>用户访问/about</p></li> <li><p>Nextjs服务端收到请求， 调用pages/about.js中的组件</p></li> <li><p>如果页面定义了<code>getServerSideProps</code>，Next.js 会在服务器上执行该函数获取数据。</p></li> <li><p>拿到props后， nextjs会应用React（server render）来生成HTML字符串</p></li> <li><p>服务端讲HTML与预渲染的props以<script></script></p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/19/2025, 3:09:05 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-progress-track/assets/js/app.55fbb09c.js" defer></script><script src="/front-end-progress-track/assets/js/2.3c044b6f.js" defer></script><script src="/front-end-progress-track/assets/js/1.946bbbaf.js" defer></script><script src="/front-end-progress-track/assets/js/28.7910915e.js" defer></script>
  </body>
</html>
