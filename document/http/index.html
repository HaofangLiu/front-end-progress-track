<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络 | Lucas文档库</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="compass.svg">
    <meta name="description" content="Lucas document collection">
    
    <link rel="preload" href="/front-end-progress-track/assets/css/0.styles.1c631b42.css" as="style"><link rel="preload" href="/front-end-progress-track/assets/js/app.55fbb09c.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/2.3c044b6f.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/1.946bbbaf.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/19.261180c5.js" as="script"><link rel="prefetch" href="/front-end-progress-track/assets/js/10.100ad0ba.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/11.11c89185.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/12.452422eb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/13.cdbffaeb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/14.29cb1f24.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/15.25a9f6f1.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/16.1008613e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/17.e87875c8.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/18.21caedd4.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/20.35b1a1eb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/21.e78369f6.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/22.67b70316.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/23.f866a84e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/24.6ffc8fb8.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/25.2594d9bd.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/26.3cdec195.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/27.98585499.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/28.7910915e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/29.a483cbdd.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/3.945872b5.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/30.c84d22d4.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/31.982a1c57.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/32.3c98e77b.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/33.17ee5942.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/34.1e87628b.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/35.6e127866.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/36.5af02e95.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/37.065e5dc3.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/4.e5e6a7bb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/5.d63af971.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/6.489cfffe.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/7.0c7d04fe.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/vendors~docsearch.c632dcce.js">
    <link rel="stylesheet" href="/front-end-progress-track/assets/css/0.styles.1c631b42.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-progress-track/" class="home-link router-link-active"><img src="/front-end-progress-track/compass.svg" alt="Lucas文档库" class="logo"> <span class="site-name can-hide">Lucas文档库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/http/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/nodejs/" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/ts/" class="nav-link">
  Typescript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/document/http/.html" class="nav-link">
  Github
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/http/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/nodejs/" class="nav-link">
  NodeJS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/ts/" class="nav-link">
  Typescript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/document/http/.html" class="nav-link">
  Github
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-progress-track/document/http/#osi-七层模型" class="sidebar-link">OSI 七层模型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#应用层协议-vs-传输层协议" class="sidebar-link">应用层协议 vs 传输层协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#关于-tcp-协议" class="sidebar-link">关于 TCP 协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#tcp-报文格式" class="sidebar-link">TCP 报文格式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#三步握手" class="sidebar-link">三步握手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#为什么不能是两步" class="sidebar-link">为什么不能是两步？</a></li></ul></li><li><a href="/front-end-progress-track/document/http/#四次挥手" class="sidebar-link">四次挥手</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#状态码" class="sidebar-link">状态码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/http/#http-报文" class="sidebar-link">HTTP 报文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#请求、响应报文应该由以下内容组成" class="sidebar-link">请求、响应报文应该由以下内容组成：</a></li></ul></li><li><a href="/front-end-progress-track/document/http/#聊一聊浏览器的缓存机制-http-是如何控制缓存的" class="sidebar-link">聊一聊浏览器的缓存机制？（HTTP 是如何控制缓存的）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#last-modified、if-modified-since-字段有什么作用" class="sidebar-link">Last-Modified、If-Modified-Since 字段有什么作用？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#etag-和-if-none-match-字段有什么作用" class="sidebar-link">Etag 和 If-None-Match 字段有什么作用？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#last-modified-和-etag-哪个更好" class="sidebar-link">Last-Modified 和 Etag 哪个更好？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#expires-字段是什么意思" class="sidebar-link">Expires 字段是什么意思？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#expires-和-cache-control-有什么区别" class="sidebar-link">Expires 和 Cache-Control 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cache-control-max-age-3600-是什么意思" class="sidebar-link">Cache-Control: max-age=3600 是什么意思？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cache-control-no-cache-是什么意思" class="sidebar-link">Cache-Control: no-cache 是什么意思？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cache-control-no-store-是什么意思" class="sidebar-link">Cache-Control: no-store 是什么意思？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cache-control-private、public-分别是什么意思" class="sidebar-link">Cache-Control: private、public 分别是什么意思？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cache-control-no-cache-和-cache-control-no-store-有什么区别" class="sidebar-link">Cache-Control: no-cache 和 Cache-Control: no-store 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#connection-keep-alive" class="sidebar-link">connection: keep-alive</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#cookie-鉴权" class="sidebar-link">cookie 鉴权</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#token-鉴权" class="sidebar-link">Token 鉴权</a></li></ul></li><li><a href="/front-end-progress-track/document/http/#http2" class="sidebar-link">HTTP2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#http2-0-的特性、为什么有这些变化、好在哪里" class="sidebar-link">HTTP2.0 的特性、为什么有这些变化、好在哪里</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#http3-改进" class="sidebar-link">HTTP3 改进</a></li></ul></li><li><a href="/front-end-progress-track/document/http/#加密" class="sidebar-link">加密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#对称加密" class="sidebar-link">对称加密</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#非对称加密" class="sidebar-link">非对称加密</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/http/#对称加密与非对称加密的区别" class="sidebar-link">对称加密与非对称加密的区别</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h1> <h2 id="osi-七层模型"><a href="#osi-七层模型" class="header-anchor">#</a> OSI 七层模型</h2> <ul><li>物理层：底层数据传输，如网线；网卡标准.</li> <li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡 MAC 地址.交换机就处在这一层</li> <li>网络层：定义 IP 编址，定义路由功能；如不同设备的数据转发.</li> <li>传输层：端到端传输数据的基本功能；如 TCP、UDP.</li> <li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件. 比如 DNS</li> <li>表示层：数据格式标识，基本压缩加密功能.</li> <li>应用层：各种应用软件，包括 Web 应用.</li></ul> <h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <h2 id="应用层协议-vs-传输层协议"><a href="#应用层协议-vs-传输层协议" class="header-anchor">#</a> 应用层协议 vs 传输层协议</h2> <ul><li>应用层协议 POP3 HTTP</li> <li>传输层协议 TCP UDP</li></ul> <h2 id="关于-tcp-协议"><a href="#关于-tcp-协议" class="header-anchor">#</a> 关于 TCP 协议</h2> <ul><li>TCP（Transmission Control Protocol， 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。与之对应的是 UDP（User Datagram Protocol ，用户数据报协议），是不可靠的传输层协议。</li></ul> <h2 id="tcp-报文格式"><a href="#tcp-报文格式" class="header-anchor">#</a> TCP 报文格式</h2> <p><img src="/front-end-progress-track/assets/img/tcp.27e42744.png" alt="tcp image"></p> <ul><li>ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。</li> <li>SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。</li> <li>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
example</li> <li>报文 1: [ACK=0，SYN=1, seq=123] 这是询问报文，询问号是 123</li> <li>报文 2: [ACK=1，SYN=1, seq=234, ack=124] 这是应答+询问报文，对 seq 为 123 的报文进行应答。询问下一个报文，询问号是 234</li> <li>报文 3:[ACK=1, SYN=0, seq=124, ack=235] 这是应答报文，对 seq 为 234 的报文进行应答</li></ul> <h2 id="三步握手"><a href="#三步握手" class="header-anchor">#</a> 三步握手</h2> <p><img src="/front-end-progress-track/assets/img/2.31642911.png" alt="三步握手真实截图"></p> <p>可以想象两人用对讲机交谈。
A：Are you ok? （SYN=1，seq=100 ）
B：I am fine. And you? (ACK=1, ack=101. SYN=1, seq=200)
A：Me too. (ACK=1, ack=201)</p> <p><img src="/front-end-progress-track/assets/img/3.819ee90e.png" alt="三步握手示意图"></p> <ul><li>客户端发送 SYN=1 的询问报文给服务器端，seq 是 n，进入 SYN_SENT 状态。</li> <li>服务器端回应一个 ACK=1、SYN=1 的应答+询问报文。应答号 ack 是 n+1，询问号 seq 是 m，进入 SYN_RCVD 状态。</li> <li>客户端收到后，回应一个 ACK=1 的应答报文，应答号是 m+1，进入 Established 状态。</li></ul> <h3 id="为什么不能是两步"><a href="#为什么不能是两步" class="header-anchor">#</a> 为什么不能是两步？</h3> <ul><li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li> <li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li> <li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul> <h2 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h2> <ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li> <li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li> <li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li> <li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态- 服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</li> <li>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</li></ul> <p>这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。</p> <ul><li><p>要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p></li> <li><p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p></li></ul> <p>TCP 挥手可以只需要三次吗？
可以的。</p> <ul><li>因为服务器端收到客户端的 FIN 后，服务器端同时也要关闭连接，这样就可以把 ACK 和 FIN 合并到一起发送，节省了一个包，变成了“三次挥手”。</li></ul> <h2 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h2> <ul><li>1xx 信息响应 100 need continue</li> <li>2xx 成功响应</li> <li>3xx 重定向</li> <li>4xx 客户端错误</li> <li>5xx 服务端响应</li></ul> <p>200 success</p> <p>201 请求成功，并因此创建了一个资源， 通常是 POST，或者某些 PUT</p> <p>206 部分成功， 类似断点续传</p> <p>301 被请求的资源已经永久移动到新的位置， 如果可能返回新的地址</p> <p>302 Found 请求的资源现在临时从不同的 URI 响应请求。</p> <p>304 Not Modified 如果发送了一个带条件的 GET 请求， 而文档内容自上次访问没有改变， 则服务器会返回这个状态码。</p> <p>305 User Proxy 被请求的资源必须通过指定的代理才能被访问</p> <p>400 Bad Request 语义有误、参数有误</p> <p>401 unauthorized 当前请求需要用户验证。响应要带一个 cookie/session 来询问用户的信息</p> <p>403 forbidden 服务器理解请求，但拒绝执行。</p> <p>404 Not Found 请求失败，没有在服务器上找到资源</p> <p>405 method not allowed 请求中指定的方法不能被用于请求相应的资源</p> <p>500 Internal server error 服务器遇到了不知道如何处理的情况</p> <p>501 not implemented 服务器不支持当前请求所需要的某个功能</p> <p>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器收到无效的响应</p> <p>503 service unavailable 服务器没有准备好处理请求， 常见原因是服务器因维护或重载停机</p> <p>504 Gateway Timeout 当服务器作为网关， 不能及时响应时返回这个代码</p> <p>505 HTTP Version Not supported 服务器不支持请求中所使用的 http 协议版本</p> <h2 id="http-报文"><a href="#http-报文" class="header-anchor">#</a> HTTP 报文</h2> <h3 id="请求、响应报文应该由以下内容组成"><a href="#请求、响应报文应该由以下内容组成" class="header-anchor">#</a> 请求、响应报文应该由以下内容组成：</h3> <ul><li>请求行，例如：GET /logo.gif HTTP/1.1 或状态码行，例如：HTTP/1.1 200 OK，</li> <li>HTTP 头字段</li> <li>空行</li> <li>可选的 HTTP 报文主体数据</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 响应样例
POST /auth/login HTTP/1.1
Host: blog-server.hunger-valley.com
Connection: keep-alive
Content-Length: 41
Accept: application/json, text/plain, */*
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imh1bmdlciIsImlkIjoxLCJpYXQiOjE2MTExMjc1MjMsImV4cCI6MTYxMTM4NjcyM30.U-CkNW7WU0zprsjI23eK-0TE5wS_gD-2ZTFW8wE31FU
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36
Content-Type: application/json;charset=UTF-8
Origin: https://jirengu-inc.github.io
Referer: https://jirengu-inc.github.io/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
{&quot;username&quot;:&quot;hunger&quot;,&quot;password&quot;:&quot;123456&quot;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// 请求案例
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Wed, 20 Jan 2021 07:28:09 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 406
Connection: keep-alive
X-Powered-By: Express
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, PUT, POST, DELETE, PATCH, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
ETag: W/&quot;196-Ay8U/71Rt0EbDzvYIuK2YtXe7xE&quot;
{&quot;status&quot;:&quot;ok&quot;,&quot;msg&quot;:&quot;登录成功&quot;,&quot;data&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;hunger&quot;,&quot;avatar&quot;:&quot;https://avatars.dicebear.com/api/human/hunger.svg?mood[]=happy&quot;,&quot;createdAt&quot;:&quot;2020-09-17T03:03:55.803Z&quot;,&quot;updatedAt&quot;:&quot;2020-09-17T03:03:55.803Z&quot;},&quot;token&quot;:&quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imh1bmdlciIsImlkIjoxLCJpYXQiOjE2MTExMjc2ODksImV4cCI6MTYxMTM4Njg4OX0.dcO4DTvWAVYPPL5do3j9zyfa48-69j157iAiXae5yrw&quot;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>请求报文首部字段的作用是说明： 我是谁，我有哪些信息，我希望对方给我什么
响应报文首部字段的作用是说明：我的内容是什么，你要做什么，给你什么</p> <ul><li>Host：请求首部，我当前请求的域名是什么</li> <li>Connection： 通用（请求和响应都用到）首部，我们之间用怎样的连接方式，常用值 keep-alive</li> <li>Content-Type：通用首部，我的报文内容的数据格式是什么</li> <li>Origin： 请求首部，我这个请求是哪个页面的域名发出来的</li> <li>Referer： 请求首部，发出我这个请求的页面是从哪个链接跳转进来的</li> <li>Accept：请求首部，我接收哪些类型的数据</li> <li>User-Agent: 请求首部， 发我这个请求的浏览器信息是什么</li> <li>Access-Control-Allow-Origin：响应首部， 我(服务器)允许来自哪些域名的页面能接收数据</li> <li>If-Modified-Since： 请求首部，这个资源上次修改的时间是这个时间，服务器你看看过期了没，过期了就给我新资源，没过期就给我发 304</li> <li>If-None-Match: 请求首部，这个资源的 tag 是这个编号，服务器你看看你存储的这个资源有没有修改过，如果修改过就给我发新资源，没修改过就发 304</li> <li>Etag：响应首部， 我（服务器）给你的这个资源的编号是这个，你存起来</li> <li>Last-Modified： 响应首部， 我（服务器）给你的这个资源的修改时间是这个，你存起来，下次要的时候把这个日期带给我</li> <li>Cache-Control：通用首部， 资源本地缓存的时间由这个控制</li> <li>Authorization：请求首部，这是我的身份信息，服务器你收到后验证一下</li> <li>Cookie：请求首部，这是我的 cookie，服务器你收到后 u 验证一下</li> <li>Set-Cookie：响应首部，我是服务器，要把 cookie 设置到浏览器</li> <li>Location：响应首部， 我是服务器， 客户端你看到 301 和 302 的状态码就做跳转吧，这是你要跳转的地址</li></ul> <h2 id="聊一聊浏览器的缓存机制-http-是如何控制缓存的"><a href="#聊一聊浏览器的缓存机制-http-是如何控制缓存的" class="header-anchor">#</a> 聊一聊浏览器的缓存机制？（HTTP 是如何控制缓存的）</h2> <p>浏览器第一次向服务器发请求获取资源，服务器响应报文的状态码是 200，响应头会带上 Cache-Control、Etag 字段，响应体是原始资源。浏览器收到响应后把资源缓存在本地。
当浏览器再次发送请求获取该资源时，浏览器先检查该资源是否过期（通过之前响应报文的 Cache-Control:max-age=过期时间来判断）。如果在过期时间以内，直接使用该资源。
如果时间过期，则发请求询问该资源是否依旧可用。请求包含头字段 If-None-Match ，是之前响应报文里的 Etag。</p> <p>服务器收到请求后通过 If-None-Match 里的 Etag 和新计算的 Etag 做对比，如果匹配，则直接返回一个状态码为 304，不包含响应体的报文，告诉浏览器该资源依旧可用。如果不匹配，则返回一个状态码为 200 带 Cache-Control、Etag 和原始资源的新报文。</p> <p>如果不存在 Etag，则用 Last-Modified 和 If-Modified-Since 做类似的判断。</p> <h3 id="last-modified、if-modified-since-字段有什么作用"><a href="#last-modified、if-modified-since-字段有什么作用" class="header-anchor">#</a> Last-Modified、If-Modified-Since 字段有什么作用？</h3> <p>当浏览器向服务器请求资源，服务器给出响应时会带上资源的修改时间，如 last-modified: Fri, 16 Oct 2020 04:15:40 GMT 。浏览器下次向服务器请求该图片时会带上 if-modified-since: Fri, 16 Oct 2020 04:15:40 GMT 。服务器可根据请求的文件修改时间和真实的文件修改时间做比较，来判断资源是否过期。</p> <h3 id="etag-和-if-none-match-字段有什么作用"><a href="#etag-和-if-none-match-字段有什么作用" class="header-anchor">#</a> Etag 和 If-None-Match 字段有什么作用？</h3> <p>Etag 相当于给资源打个标记生成“独一无二”的指纹。当文件在服务端被修改时，Etag 就会改变。其作用和 Last-Modify 类似。在现实环境中，这个独一无二并不严谨。</p> <h3 id="last-modified-和-etag-哪个更好"><a href="#last-modified-和-etag-哪个更好" class="header-anchor">#</a> Last-Modified 和 Etag 哪个更好？</h3> <p>二者作用一样，大多数服务器生成 Etag 就是由 “文件的修改时间”和“资源的长度”两个因子生成。当然还有一些细微的差异。第一，Last-Modified 的单位是秒，如果在一秒内对文件进行修改，使用 Last-Modified 不变，但 Etag 一般会发生改变。第二，二者在语义上也有差异，一个是文件的修改时间，一个是文件的指纹。第三，使用 Last-Modified，浏览器端可以直接看到文件的修改时间，对服务器来说这个信息的暴露是画蛇添足的。</p> <h3 id="expires-字段是什么意思"><a href="#expires-字段是什么意思" class="header-anchor">#</a> Expires 字段是什么意思？</h3> <p>这是 HTTP1.0 版本的报文字段，代表资源的过期时间，如 Expires: Wed, 21 Oct 2021 07:28:00 GMT 。如果设置了 Cache-control: max-age=过期秒数，Expires 会被忽略。</p> <h3 id="expires-和-cache-control-有什么区别"><a href="#expires-和-cache-control-有什么区别" class="header-anchor">#</a> Expires 和 Cache-Control 有什么区别？</h3> <p>第一，Expires 的值是一个 GMT 的时间点，代表到什么时间点过期；Cache-Control: max-age=值 这个值是一个以秒为单位的时间段，代表有效期是多少秒。第二，Cache-Control 还能设置更复杂的场景，比如 Cache-Control: no-cache、no-store、private 等。第三，如果服务器告诉所有的浏览器某资源在 2022 年 1 月 1 日到期，到了该时间点时需要该资源的浏览器都会在同一时间发请求。而如果服务器告诉所有浏览器某资源在各自存储 100 天，因为第一次请求的时间不一样，再次需要该资源的浏览器不会同时发请求。</p> <h3 id="cache-control-max-age-3600-是什么意思"><a href="#cache-control-max-age-3600-是什么意思" class="header-anchor">#</a> Cache-Control: max-age=3600 是什么意思？</h3> <p>服务器告诉浏览器，这个资源在本地缓存下来，如果再次需要该资源并且是在 3600 秒以内，不要发请求直接使用这个资源。如果超出 3600 秒，再发请求向服务器询问是否能继续使用。</p> <h3 id="cache-control-no-cache-是什么意思"><a href="#cache-control-no-cache-是什么意思" class="header-anchor">#</a> Cache-Control: no-cache 是什么意思？</h3> <p>告诉浏览器，收到这个资源先缓存下来，下次需要该资源时不要立即使用，而是先向服务器确认该资源的有效性，再使用。等同于 max-age=0。</p> <h3 id="cache-control-no-store-是什么意思"><a href="#cache-control-no-store-是什么意思" class="header-anchor">#</a> Cache-Control: no-store 是什么意思？</h3> <p>告诉浏览器，收到资源不要存储。下次需要该资源时直接发请求，服务器给你最新的。</p> <h3 id="cache-control-private、public-分别是什么意思"><a href="#cache-control-private、public-分别是什么意思" class="header-anchor">#</a> Cache-Control: private、public 分别是什么意思？</h3> <p>private 是告诉中间的代理服务器不要缓存资源，只让目标浏览器缓存。public 是都能缓存。</p> <h3 id="cache-control-no-cache-和-cache-control-no-store-有什么区别"><a href="#cache-control-no-cache-和-cache-control-no-store-有什么区别" class="header-anchor">#</a> Cache-Control: no-cache 和 Cache-Control: no-store 有什么区别？</h3> <p>一个收到存下来不直接用，再次确认后再用。 一个是完全不存。</p> <h3 id="connection-keep-alive"><a href="#connection-keep-alive" class="header-anchor">#</a> connection: keep-alive</h3> <p>HTTP 1.0 存在问题： 建立的一次连接，只有包含一个请求响应（对应一个资源）</p> <p>HTTP1.1</p> <ul><li><p>改进 1: 连接可以复用。一次连接，多个请求响应（对应多个资源）</p></li> <li><p>改进 2：增加流水线（pipeline）操作。下一个请求可不用等上一个响应来之后再发送。（但响应到来的顺序不变 FIFO）</p></li> <li><p>http1.1 中默认开启，通过 http 请求头设置“connection: close”关闭。</p></li> <li><p>http1.0 默认是关闭的，通过 http 请求头设置“connection: keep-alive”进行开启</p></li></ul> <p>依旧存在的问题：</p> <ol><li>请求按次序，后来者需要排队等待</li> <li>请求头都类似，重复传输浪费资源</li> <li>同一域名浏览器有最大并行请求限制</li></ol> <h3 id="cookie-鉴权"><a href="#cookie-鉴权" class="header-anchor">#</a> cookie 鉴权</h3> <p>请求</p> <p>POST /login HTTP/1.1
Host: jirengu.com
Content-Type: application/json;charset=UTF-8</p> <p>{username: &quot;hunger&quot;, password: &quot;123456&quot;}</p> <p>响应</p> <p>HTTP/1.1 200 OK</p> <p>Content-Type: application/json; charset=utf-8</p> <p>set-cookie: sid=abc24sf; Path=/; Expires=Wed, 03 Feb 2021 12:14:36 GMT; HttpOnly; Secure; SameSite=Strict</p> <p>{&quot;status&quot;: &quot;ok&quot;}</p> <ul><li>set-cookie 告诉浏览器我要种 cookie</li> <li>在 Wed, 21 Oct 2021 06:18:00 GMT 时这个 cookie 失效</li> <li>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端</li> <li>使用 HttpOnly 属性告诉浏览器禁止通过 JavaScript 访问 cookie 值</li> <li>SameSite=Strict 告诉浏览器跨域请求时不要带上 cookie，设置为 none 时表示跨域也能带上</li></ul> <p>GET /search HTTP/1.1</p> <p>Host: xxx.com</p> <p>Cookie: sid=abc24sf;</p> <p>{&quot;q&quot;:&quot;asd&quot;}</p> <p>带着 cookie 去请求，服务器可以识别身份。</p> <h3 id="token-鉴权"><a href="#token-鉴权" class="header-anchor">#</a> Token 鉴权</h3> <p>请求</p> <p>POST /login HTTP/1.1</p> <p>Host: xxx.com</p> <p>Content-Type: application/json;charset=UTF-8</p> <p>{username: &quot;hunger&quot;, password: &quot;123456&quot;}</p> <p>响应</p> <p>HTTP/1.1 200 OK</p> <p>Content-Type: application/json; charset=utf-8</p> <p>{&quot;status&quot;: &quot;ok&quot;, &quot;token&quot;: &quot;abcd1234&quot;}</p> <p>请求</p> <p>GET /search HTTP/1.1</p> <p>Host: xxx.com</p> <p>Cookie: sid=abc24sf</p> <p>Authorization: Bearer abcd1234</p> <p>{&quot;q&quot;:&quot;kkk&quot;}</p> <p>用 Aurorization 带着 token 去请求，服务器可以识别身份。</p> <h4 id="withcredentials"><a href="#withcredentials" class="header-anchor">#</a> withCredentials</h4> <p>XMLHttpRequest.withCredentials 属性是一个 Boolean 类型，它指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site Access-Control）请求。在同一个站点下使用 withCredentials 属性是无效的。</p> <p>如果在发送来自其他域的 XMLHttpRequest 请求之前，未设置 withCredentials 为 true，那么就不能为它自己的域设置 cookie 值。而通过设置 withCredentials 为 true 获得的第三方 cookies，将会依旧享受同源策略，因此不能被通过 document.cookie 或者从头部相应请求的脚本等访问。</p> <h2 id="http2"><a href="#http2" class="header-anchor">#</a> HTTP2</h2> <p>基于二进制流。 将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。
将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装。</p> <p>并行交错地发送多个请求，请求之间互不影响。
并行交错地发送多个响应，响应之间互不干扰。
使用一个连接并行发送多个请求和响应。</p> <p><img src="/front-end-progress-track/assets/img/4.ae09920e.svg" alt="http2"></p> <h3 id="http2-0-的特性、为什么有这些变化、好在哪里"><a href="#http2-0-的特性、为什么有这些变化、好在哪里" class="header-anchor">#</a> HTTP2.0 的特性、为什么有这些变化、好在哪里</h3> <p>Http1.x 存在的问题</p> <ol><li>pipeling 传输方式浏览器在处理时有各自问题和 bug，所以一般默认也未开启支持。另外对于大文件依旧会存在服务器阻塞。</li> <li>主流用的还是 keep-alive，在一个连接里资源的请求是串行的。为了加快并行速度浏览器会开多个连接，一个域名默认最多开约 6 个连接，超过限制数目的请求会被阻塞。（所以一些网站静态资源使用了多个域名，但域名太多管理不便且域名解析也需要时间）</li> <li>只能客户端主动发起请求，不能服务器主动发起</li> <li>请求/响应首部太大了，未经压缩就发送，浪费</li> <li>每次请求/响应的首部大都是冗余的重复的内容</li> <li>数据压缩非强制，可能存在未经压缩的情况</li> <li>请求顺序没优先级，只能听天命(HTML 资源顺序)</li> <li>客户端可以解析 html 发送一个个的资源请求，服务器也能啊</li> <li>更多...</li></ol> <p>Http2.0 的改进</p> <ol><li>基于二进制流。 将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。</li> <li>多路复用(Multiplexing)。一个 TCP 连接，可以无限制处理多个请求</li> <li>请求可以设置优先级</li> <li>压缩 Http 首部</li> <li>服务器推送(Server Push) 。客户端发送获取 HTML 的请求，服务器把 HTML 以及 HTML 里需要的资源一起发过去</li> <li>服务器提示(Server Hints)，preload 和 prefetch。 浏览器会在空闲的时间加载这个大的图片，下次请求可能会用到</li></ol> <h3 id="http3-改进"><a href="#http3-改进" class="header-anchor">#</a> HTTP3 改进</h3> <p>HTTP / 3 是 HTTP 即将发布的主要版本。HTTP 语义在各个版本之间是一致的：相同的请求方法，状态代码和消息字段通常适用于所有版本。不同之处在于这些语义到基础传输的映射。HTTP / 1.1 和 HTTP / 2 使用 TCP 作为其传输。HTTP / 3 使用 QUIC，这是 Google 最初开发的一种基于 UDP 的传输层网络协议。改用 QUIC 的目的是解决 HTTP / 2 的一个主要问题 HOL 阻塞 (head-of-line blocking) 。HTTP / 1.1 中的 HOL 是指当浏览器中允许的并行请求数用完时，随后的请求需要等待前一个请求完成。HTTP / 2 通过请求复用解决了此问题，该复用消除了应用程序层的 HOL 阻塞，但 HOL 仍存在于传输（TCP）层。</p> <p>小知识 Preload 与 Server Push</p> <ul><li>preload 预加载，告诉浏览器下一步立即要加载什么资源。<link rel="preload" href="https://example.com/images/large-background.jpg"></li> <li>prefetch 预加载，告诉浏览器下一步要加载什么资源。在空闲时加载。<link rel="preload" href="https://example.com/images/music.mp3"></li></ul> <h2 id="加密"><a href="#加密" class="header-anchor">#</a> 加密</h2> <h3 id="对称加密"><a href="#对称加密" class="header-anchor">#</a> 对称加密</h3> <p>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p> <p>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</p> <h3 id="非对称加密"><a href="#非对称加密" class="header-anchor">#</a> 非对称加密</h3> <p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人--银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p> <h3 id="对称加密与非对称加密的区别"><a href="#对称加密与非对称加密的区别" class="header-anchor">#</a> 对称加密与非对称加密的区别</h3> <p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。为了解释这个过程，请看下面的例子：</p> <p>（1） Alice需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。</p> <p>（2） Alice的浏览器向银行的网站请求公钥。</p> <p>（3） 银行将公钥发送给Alice。</p> <p>（4） Alice的浏览器使用银行的公钥将自己的对称密钥加密。</p> <p>（5） Alice的浏览器将加密后的对称密钥发送给银行。</p> <p>（6） 银行使用私钥解密得到Alice浏览器的对称密钥。</p> <p>（7） Alice与银行可以使用对称密钥来对沟通的内容进行加密与解密了。</p> <p>总结：</p> <ul><li><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p></li> <li><p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p></li> <li><p>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/11/2022, 5:22:21 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-progress-track/assets/js/app.55fbb09c.js" defer></script><script src="/front-end-progress-track/assets/js/2.3c044b6f.js" defer></script><script src="/front-end-progress-track/assets/js/1.946bbbaf.js" defer></script><script src="/front-end-progress-track/assets/js/19.261180c5.js" defer></script>
  </body>
</html>
