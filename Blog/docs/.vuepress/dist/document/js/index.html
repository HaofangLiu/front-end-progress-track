<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Javascript 相关知识点 | Lucas文档库</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="compass.svg">
    <meta name="description" content="Lucas document collection">
    
    <link rel="preload" href="/front-end-progress-track/assets/css/0.styles.e441acb6.css" as="style"><link rel="preload" href="/front-end-progress-track/assets/js/app.7ad0e47c.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/2.41268747.js" as="script"><link rel="preload" href="/front-end-progress-track/assets/js/12.e9fe9892.js" as="script"><link rel="prefetch" href="/front-end-progress-track/assets/js/10.7ea92009.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/11.ca7a2bfb.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/3.715098d8.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/4.da2b4a47.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/5.f2766a6e.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/6.0f97e1c1.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/7.1e1bb199.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/8.b79ce353.js"><link rel="prefetch" href="/front-end-progress-track/assets/js/9.49a0f12a.js">
    <link rel="stylesheet" href="/front-end-progress-track/assets/css/0.styles.e441acb6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-progress-track/" class="home-link router-link-active"><img src="/front-end-progress-track/compass.svg" alt="Lucas文档库" class="logo"> <span class="site-name can-hide">Lucas文档库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Javascript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/guide/" class="nav-link">
  导向
</a></div><div class="nav-item"><a href="/front-end-progress-track/document/js/.html" class="nav-link">
  Github
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-progress-track/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/front-end-progress-track/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文档" class="dropdown-title"><span class="title">文档</span> <span class="arrow down"></span></button> <button type="button" aria-label="文档" class="mobile-dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front-end-progress-track/document/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Javascript
</a></li></ul></div></div><div class="nav-item"><a href="/front-end-progress-track/guide/" class="nav-link">
  导向
</a></div><div class="nav-item"><a href="/front-end-progress-track/document/js/.html" class="nav-link">
  Github
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Javascript 相关知识点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-progress-track/document/js/#地址栏输入-url-后发生了什么" class="sidebar-link">地址栏输入 URL 后发生了什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#浏览器的渲染机制" class="sidebar-link">浏览器的渲染机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#重绘-repaint-和-回流-reflow" class="sidebar-link">重绘 Repaint 和 回流 Reflow</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#图片的请求" class="sidebar-link">图片的请求</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#阻塞解析与阻塞渲染" class="sidebar-link">阻塞解析与阻塞渲染</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#css-加载" class="sidebar-link">CSS 加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#js-记载" class="sidebar-link">JS 记载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#异步加载-async-与-defer" class="sidebar-link">异步加载 async 与 defer</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#函数两种声明方式" class="sidebar-link">函数两种声明方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#函数声明" class="sidebar-link">函数声明</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#函数表达式" class="sidebar-link">函数表达式</a></li></ul></li><li><a href="/front-end-progress-track/document/js/#运行环境" class="sidebar-link">运行环境</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#作用域链" class="sidebar-link">作用域链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#递归-自己调用自己" class="sidebar-link">递归（自己调用自己）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#字符串相关" class="sidebar-link">字符串相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#数组相关" class="sidebar-link">数组相关</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#js-内置对象" class="sidebar-link">JS 内置对象</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#date" class="sidebar-link">Date</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#math" class="sidebar-link">Math</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#正则表达式" class="sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#异步与回调" class="sidebar-link">异步与回调</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#多个逻辑运算符" class="sidebar-link">多个逻辑运算符</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#dom-文档对象模型" class="sidebar-link">DOM 文档对象模型</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#dom-事件" class="sidebar-link">DOM 事件</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#class-操作" class="sidebar-link">class 操作</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#属性操作" class="sidebar-link">属性操作</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#元素创建" class="sidebar-link">元素创建</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#元素复制添加修改删除" class="sidebar-link">元素复制添加修改删除</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#获取样式" class="sidebar-link">获取样式</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#js-事件" class="sidebar-link">JS 事件</a></li></ul></li><li><a href="/front-end-progress-track/document/js/#dom-事件流" class="sidebar-link">DOM 事件流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#事件代理" class="sidebar-link">事件代理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#bom-浏览器对象模型" class="sidebar-link">BOM 浏览器对象模型</a></li></ul></li><li><a href="/front-end-progress-track/document/js/#检测设备" class="sidebar-link">检测设备</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#滚动" class="sidebar-link">滚动</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#cookie-seesion" class="sidebar-link">cookie seesion</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#如何与后端交互" class="sidebar-link">如何与后端交互</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#回调-异步" class="sidebar-link">回调&amp;异步</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#跨域" class="sidebar-link">跨域</a></li></ul></li><li><a href="/front-end-progress-track/document/js/#jsonp" class="sidebar-link">JSONP</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#cors-跨域资源共享" class="sidebar-link">CORS 跨域资源共享</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/front-end-progress-track/document/js/#服务器代理" class="sidebar-link">服务器代理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#withcredentials" class="sidebar-link">withCredentials：</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#samesite" class="sidebar-link">sameSite</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#httponly" class="sidebar-link">httponly</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#nodejs-npm-yarn-commonjs" class="sidebar-link">nodejs npm yarn commonJS</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#模块化" class="sidebar-link">模块化</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#webpack" class="sidebar-link">webpack</a></li><li class="sidebar-sub-header"><a href="/front-end-progress-track/document/js/#entry" class="sidebar-link">entry</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-相关知识点"><a href="#javascript-相关知识点" class="header-anchor">#</a> Javascript 相关知识点</h1> <h2 id="地址栏输入-url-后发生了什么"><a href="#地址栏输入-url-后发生了什么" class="header-anchor">#</a> 地址栏输入 URL 后发生了什么</h2> <ol><li>DNS 域名解析；（浏览器缓存、系统缓存、路由器缓存、ISP 缓存、DNS 服务器）</li> <li>建立 TCP 连接；</li> <li>发送 HTTP 请求；</li> <li>服务器处理请求；（web 服务器处理请求。 eg. apache、ngnix 等）</li> <li>返回响应结果；</li> <li>关闭 TCP 连接；</li> <li>浏览器解析 HTML；</li> <li>浏览器布局渲染；</li></ol> <h2 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="header-anchor">#</a> 浏览器的渲染机制</h2> <ol><li>解析 HTML 标签, 构建 DOM 树</li> <li>解析 CSS, 构建 CSSOM 树 （对象模型 object model）</li> <li>把 DOM 和 CSSOM 组合成 渲染树 (render tree)</li> <li>在渲染树的基础上进行布局, 计算每个节点的几何结构</li> <li>把每个节点绘制到屏幕上 (painting)</li></ol> <h2 id="重绘-repaint-和-回流-reflow"><a href="#重绘-repaint-和-回流-reflow" class="header-anchor">#</a> 重绘 Repaint 和 回流 Reflow</h2> <ul><li>重绘 绘制界面发生变化的部分（比如颜色发生变化）</li> <li>回流 重新计算元素的几何尺寸，位置（页面节点消失，余下的节点向上移）</li> <li>举例：</li> <li>添加、删除、更新 DOM 节点(reflow 、repaint)</li> <li>修改元素的 magin、padding、border（reflow、repaint）</li> <li>display: none（reflow、repaint） 节点消失，从文档流删除</li> <li>visibility: hidden（repaint）</li> <li>修改颜色、背景色(repaint)</li></ul> <h2 id="图片的请求"><a href="#图片的请求" class="header-anchor">#</a> 图片的请求</h2> <ul><li>图片的加载不会影响其他资源的加载或者页面的渲染</li> <li>不发请求的情况：
<ol><li>css 中写了一个无效的样式（比如选择器选中了一个不存在的节点）</li> <li>父亲设置了 display:none，脱离了文档流（加入节点自己设置了 display:none 也会发送请求）</li></ol></li> <li>visibility:none 都会发送请求</li> <li>html 的 img 标签都会发送请求</li></ul> <h2 id="阻塞解析与阻塞渲染"><a href="#阻塞解析与阻塞渲染" class="header-anchor">#</a> 阻塞解析与阻塞渲染</h2> <p>阻塞解析: 阻塞点后面的标签不会被解析，阻塞解析不一定阻塞其他外部资源的加载
阻塞渲染: 阻塞点后面的标签会继续被解析，img,link 等会继续发送请求获取外部资源，但不会触发页面渲染（白屏），也不会执行 JavaScript 代码。</p> <h2 id="css-加载"><a href="#css-加载" class="header-anchor">#</a> CSS 加载</h2> <ul><li>CSS 加载不会阻塞解析，但会阻塞渲染</li> <li>现象：
<ol><li>白屏（DOM 节点已经有了，但是 css 还在获取，加载时间久，还没有绘制出来）---&gt;样式放在 header</li> <li>FOUC（flash of unstyle content）先展示无样式内容，突然样式正常---&gt;样式放在 body</li></ol></li> <li>结论： 尽量 link 标签放在 head 内部，防止出现 FOUC。但是可以通过处理（加载骨架）防止 FOUC</li></ul> <h2 id="js-记载"><a href="#js-记载" class="header-anchor">#</a> JS 记载</h2> <ul><li>JS 的加载和执行会阻塞解析（JS 加载完成会立刻执行）</li> <li>结论： 尽量把外置 JS 放在 body 最后，以便 DOM 尽快展现，同时方便 JS 操作 DOM</li></ul> <h2 id="异步加载-async-与-defer"><a href="#异步加载-async-与-defer" class="header-anchor">#</a> 异步加载 async 与 defer</h2> <ul><li><p><code>&lt;script async src=&quot;script1.js&quot;&gt;&lt;/script&gt;</code></p></li> <li><p>async: 加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行 进行（异步）</p></li> <li><p><code>&lt;script defer src=&quot;script1.js&quot;&gt;&lt;/script&gt;</code></p></li> <li><p>defer: 加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但 script.js 的执行要在所有元素解析完成之后执行</p></li> <li><p>async
async 的存在不影响 DOM 的解析和其他资源的加载， 特例独行，不保证顺序，不保证时机</p></li> <li><p>defer
defer 存在不影响 DOM 的解析和其他资源的加载， 但是会保证在 DOM 资源准备就绪后再执行，并且对 于多个 defer 的外置 js 按顺序执行</p></li></ul> <p>运算符以及非严格比较的一些注意事项！<a href="https://zhuanlan.zhihu.com/p/351409061" target="_blank" rel="noopener noreferrer">关于运算符的一些表现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="函数两种声明方式"><a href="#函数两种声明方式" class="header-anchor">#</a> 函数两种声明方式</h2> <h3 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h3> <p><code>function sum(x,y){}</code> ( 这种声明方式允许调用在前，声明在后)</p> <h3 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h3> <p><code>const sum = function (x,y) {}</code></p> <h2 id="运行环境"><a href="#运行环境" class="header-anchor">#</a> 运行环境</h2> <ul><li>全局环境</li> <li>函数环境</li> <li>JS 在运行时会有执行[栈]来依次存放运行环境</li></ul> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <ul><li>函数在运行的过程中，先从自己内部找变量</li> <li>如果找不到，再从创建当前函数所在的作用域（词法作用域）去找，依次往上，直到全局作用域</li> <li>注意找的是变量的此刻的状态</li></ul> <h2 id="递归-自己调用自己"><a href="#递归-自己调用自己" class="header-anchor">#</a> 递归（自己调用自己）</h2> <ul><li></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const fact = n =&gt; {
  if(n === 1) return 1;
  return n *(fact(n - 1))
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>const fib = (n) =&gt; {
  if ( n === 1 || n === 2) return 1;
  return fib(n-1) + fib(n - 2)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="字符串相关"><a href="#字符串相关" class="header-anchor">#</a> 字符串相关</h2> <ul><li>\ ---》 将后边的符号转译为普通符号，没有任何作用</li> <li>.length 获取字符串的长度</li> <li>str[0]字符串某一位</li> <li>str.charAt(0) 同上</li> <li>str.charCodeAt(0) 某一位的 ASCII 码</li> <li>str.search('xx')寻找某字符串的 index</li> <li>str.indexOf('xx') 同上</li> <li>str.lastIndexOf('xx')倒序寻找 xx 字符串的 index</li> <li>str.includes('xx')是否包含某字符串</li> <li>str.startsWith('c') 是否以 c 开头</li> <li>str.endsWith('x') 是否以 x 结尾</li> <li>str.substr(1,3)字符串截取，从第几位开始（包含），截取几位</li> <li>str.substring(1,3)从第几位开始（包含），到第几位结束（不包含）</li> <li>str.slice(1,3)同上</li> <li>str.split('')空字符分割字符串</li> <li>str.trim()去掉两边空白字符 // trimLeft() trimRight()</li> <li>str.toUpperCase();</li> <li>str.toLowerCase();</li> <li>str.padStart(8,'<em>')填充字符串，从前边开始填充</em>直到长度为 8</li></ul> <h2 id="数组相关"><a href="#数组相关" class="header-anchor">#</a> 数组相关</h2> <ul><li>arr[index] 获取对应的 index 的值</li> <li>arr.pop() 返回 arr 最后一项 原本 arr 会改变</li> <li>arr.push() arr 中加入一项，返回数组的新的长度 （往数组塞，返回长度）</li> <li>arr.unshift(10) arr 头部加入一项，返回数组的长度</li> <li>arr.shift() 返回 arr 拿出第一项 原本 arr 会改变</li> <li>arr.slice(start,end) 返回一个新数组，左闭右开，end 可有可无，如果没有就是到结尾</li> <li>arr.splice（a,b,c）a.开始的索引（插入则在这个 index 之前） b.删除元素的个数（返回结果 是删除的元素） c.插入的新元素 | 返回一个由删除元素组成的新数组</li> <li>arr.concat() 可以用来拼接数组（但是也可以用来浅拷贝）</li> <li>arr.join('') 空数组进行连接</li> <li>arr.reverse() 数组顺序进行倒序（会改变原来的数组）</li> <li>arr.sort() 排序 sort((a,b) =&gt;a - b) 从小到大 sort((a,b) =&gt;b - a)从大到小</li> <li>arr.index(1) 寻找某一项的 index，找不到返回-1</li> <li>arr.lastIndexOf(1) 倒序查找，找不到返回-1</li> <li>arr.forEach(value,index,array)</li> <li>arr.every(val =&gt; val &gt; 0) 所有回调函数都返回 true 的时候才会返回 true，否则返回 false</li> <li>arr.some(val =&gt; val &gt; 0)有一个回调函数都返回 true 的时候就返回 true</li> <li>arr.filter(val =&gt; val &gt; 0) 根据条件过滤出新的数组</li> <li>arr.map()遍历数组，回调函数返回值组成一个新数组返回，新数组索引结构和原数组一致，原数组不变（注意跟 foeEach 区别，forEach 没有自动创建一个新数组）</li> <li>arr.reduce(func(v1,v2), initValue)遍历数组，调用回调函数，将数组元素组合成一个值</li></ul> <h2 id="js-内置对象"><a href="#js-内置对象" class="header-anchor">#</a> JS 内置对象</h2> <ul><li>JSON.stringify</li> <li>用于把一个值变成符合 JSON 格式的字符串</li> <li>JSON.parse</li> <li>用于把一个符合 JSON 格式的字符串还原对象</li></ul> <h2 id="date"><a href="#date" class="header-anchor">#</a> Date</h2> <ul><li>new Date()获取一个时间对象</li> <li>d.getTime()返回实例对象距离 1970 年 1 月 1 日 00:00:00 对应的毫秒</li> <li>d.getDate()返回实例对象对应的每个月的几号（从 1 开始）</li> <li>d.getDay()返回星期几，星期一为 1，星期日为 0</li> <li>d.getFullYear()返回四位年份</li> <li>d.getMonth() 返回月份，一月为 0，12 月为 11</li> <li>d.getHours()返回小时(0~23)</li> <li>d.getMilliseconds()返回毫秒(0~999)</li> <li>d.getMinuts()返回分钟(0~59)</li> <li>d.getSeconds()返回秒(0~59)</li></ul> <h2 id="math"><a href="#math" class="header-anchor">#</a> Math</h2> <ul><li>Math.floor 向下取整</li> <li>Math.ceil 向上取整</li> <li>Math.round 四舍五入</li> <li>Math.abs 绝对值</li> <li>Math.max 取最大值</li> <li>Math.min 取最小值</li> <li>Math.random 随机数[0,1)</li></ul> <h2 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h2> <ul><li>/...../g 会被解析成正则表达式</li> <li><code>new RegExp('+86\d{11}','g')</code>构造函数方式创建</li> <li>g -</li> <li>i -忽略大小写，默认大小写敏感</li> <li>m -多行搜索</li> <li><code>regexp.test('aaa')</code>字符串是否符合规则,返回 boolean</li> <li><code>string.search(/abc\d/)</code>返回匹配到的第一个结果的 index，如果没有是-1</li> <li><code>string.match(/abc\d/g)</code>返回匹配到的 arr ['abc1','abc2']</li> <li><code>string.replace(/abc\d/g,'hi')</code>将 abc2 替换为 hi</li> <li><code>string.split(/\s/)</code>基于空格分离字符串，返回数组结果</li> <li>有意义的字符，需要用\转义：( [ { \ ^ $ | ) ? * + .</li> <li>[abcd]中括号：匹配一个字符，可以是 abcd 任意一个</li> <li>[0-9]同理</li> <li>[a-zA-Z]匹配一个不限制大小写的字母</li> <li>[^abc]表示一个不是 a/b/c 的字符</li> <li>. 等价于匹配一个除了回车和换行以外的任意字符[^\r\n]</li> <li>\d 等价于一个数字字符[0-9]</li> <li>\D 等价于非数字字符[^0-9]</li> <li>\s 匹配一个空白字符[ \t\n\r\v\f]匹配一个空白字符</li> <li>\S 匹配一个非空白字符</li> <li>\w 匹配一个字母数字下划线[a-zA-Z0-9_]</li> <li>\W 匹配一个非单词字符</li> <li>? 前面的字符出现 0 或者 1 次</li> <li>(+) 前面的字符出现一次或者多次</li> <li>(*) 前面的字符出现 0 次或者多次</li> <li>{n} 前面的字符出现 n 次</li> <li>{n,m} 前面的字符出现 n 到 m 次</li> <li>{n,} 前面的字符出现至少 n 次</li> <li>/^xyz/ 必须以 xyz 开头 注意区分[^]里面的是除了</li> <li>/abc$/必须以 abc 结尾</li> <li>/\babc\b/ 匹配时单词的 abc（左右两侧时字符串开头、结尾、中横线、空格）</li> <li>/\Babc\B/ 匹配不是单词的 abc</li> <li>贪婪模式：默认尽可能多的匹配，如果想使用非贪婪模式，则可以在量词后加？<code>'12345'.match(/\d{3,5}?/g)</code></li> <li>() 正则的分组，有几个括号就是$1/2/3...</li> <li>i 不区分大小写 g 全局匹配 m 多行匹配
前瞻</li> <li>exp1(?=exp2) 匹配后面是 exp2 的 exp1</li> <li>exp1(?!exp2) 匹配后面不是 exp2 的 exp1</li></ul> <h3 id="异步与回调"><a href="#异步与回调" class="header-anchor">#</a> 异步与回调</h3> <ul><li>同步任务：在主线程上等待执行任务，前一个结束后一个才会执行。</li> <li>异步任务：不进入主线程，进入任务队列，等待任务队列通知主线程，某个异步任务可以执行了，这个任务才可以进入主线程执行。</li> <li>回调函数，说的就是被挂起来的代码，异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行异步任务的回调函数</li></ul> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <ul><li>obj.<strong>proto</strong> === Class.prototype</li> <li>instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li></ul> <h3 id="多个逻辑运算符"><a href="#多个逻辑运算符" class="header-anchor">#</a> 多个逻辑运算符</h3> <ul><li><p>|| 或运算寻找第一个真值</p></li> <li><p>一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</p></li> <li><p>&amp;&amp; 与运算寻找第一个假值</p></li> <li><p>与运算返回第一个假值，如果没有假值就返回最后一个值。</p></li> <li><p>与运算 &amp;&amp; 的优先级比或运算 || 要高。</p></li></ul> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <ul><li>继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</li> <li>写在 class 的属性和方法会挂在 prototype 上</li> <li>Object.create(proto,propsDescription) 以 proto 为原型属性创建对象{}</li> <li>hasOwnProperty 判断对象自身属性中是否具有指定的属性</li> <li>Object.assign(target, source, source1,source2....) 将所有可枚举属性,从一个或多个源对象赋值到目标对象, 返回目标对象</li> <li>Mixin 通过不使用继承的方式让一个类中的方法被其他类复用 （利用 Object.assign 实现）</li> <li>getter / setter 将对象属性绑定到查询/设置该属性时将被调用的函数</li> <li>static 静态属性 使用的时候需要用类名调用，实例没办法直接调用。可以继承</li> <li>new 一个函数： 首先创建一个空对象，执行这个函数，遇到 this 就是对这个 obj 操作，最后返回创建的新对象</li> <li>方法的原型默认有一个 constructor，一般是指向自身 class、func</li> <li>class 对于 = 号声明的方法、变量，都会将其作为实例的属性，而对于非 = 号声明的属性，则是放在原型链上。</li> <li>通过箭头函数定义的方法时绑定在 this 上</li></ul> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <ul><li>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有的局部变量</li></ul> <h3 id="dom-文档对象模型"><a href="#dom-文档对象模型" class="header-anchor">#</a> DOM 文档对象模型</h3> <ul><li>document.head/.body/.title/.location(href/search/hash/reload/assign)</li> <li>node.nodeName：元素标签名，还有个类似的 tagName</li> <li>node.nodeType：元素类型</li> <li>node.className：类名</li> <li>node.id：元素 id</li> <li>node.children：子元素列表（HTMLCollection）</li> <li>node.childNodes：子元素列表（NodeList）</li> <li>node.firstChild：第一个子元素</li> <li>node.lastChild：最后一个子元素</li> <li>node.nextSibling：下一个兄弟元素</li> <li>node.previousSibling：上一个兄弟元素</li> <li>node.parentNode：父元素</li> <li>//es3 写法，不推荐</li> <li>document.getElementById('id') //Element</li> <li>document.getElementsByClassName('class') //HTMLCollection</li> <li>document.getElementsByTagName('p') //HTMLCollection，需要转化，可以用 Array.from()或者[...类数组]的方法来便利</li> <li>document.getElementsByName('username') //NodeList，有 foreach 方法</li> <li>//ES5 写法，推荐</li> <li>document.querySelector('.box') //Element</li> <li>document.querySelectorAll('.box') //NodeList</li></ul> <h3 id="dom-事件"><a href="#dom-事件" class="header-anchor">#</a> DOM 事件</h3> <p>事件绑定</p> <ul><li>node.onclick = function(e){}</li> <li>node.addEventListener('click', function(e){})</li> <li>在函数里面可以使用事件对象 e</li> <li>函数里面的 this 代表 node 本身，如果用箭头函数则没有 this（this 指向 window）</li></ul> <h3 id="class-操作"><a href="#class-操作" class="header-anchor">#</a> class 操作</h3> <ul><li>常见 API</li> <li>node.className 老方法，用起来不严谨，尽量不用</li> <li>node.classList.add</li> <li>node.classList.remove</li> <li>node.classList.contains</li> <li>node.classList.toggle</li></ul> <h3 id="属性操作"><a href="#属性操作" class="header-anchor">#</a> 属性操作</h3> <ul><li>node.getAttribute('id')</li> <li>node.setAttribute('data-id','100')</li> <li>node.removeAttribute('checked')</li> <li>document.createAttribute('checked')</li> <li>node.setAttributeNode(attrNode) ==》 node.setAttributeNode(document.createAttribute('checked'))</li></ul> <h3 id="元素创建"><a href="#元素创建" class="header-anchor">#</a> 元素创建</h3> <ul><li>document.createElement('div')</li> <li>创建 DOM 节点，参数是标签名</li> <li>document.createTextNode(&quot;Hello&quot;)</li> <li>创建文本节点，参数是字符串</li> <li>document.createDocumentFragment()</li> <li>创建一个虚拟的 DOM，用于提升性能，避免高频 DOM 操作</li></ul> <h3 id="元素复制添加修改删除"><a href="#元素复制添加修改删除" class="header-anchor">#</a> 元素复制添加修改删除</h3> <p>parentNode.appendChild(childNode)</p> <ul><li>在父亲的末尾添加元素</li> <li>parentNode.insertBefore(newNode, referenceNode)</li> <li>把 newNode 插入到 referenceNode 元素之前</li> <li>parentNode.replaceChild(newChild, oldChild)</li> <li>把 oldChild 替换为 newChild</li> <li>parentNode.removeChild(childNode)</li> <li>从 parentNode 里删除 childNode</li> <li>node.cloneNode(true)</li> <li>克隆一个元素，参数 true 的时候会深复制，也就是会复制元素及其子元素，false
的时候只复制元素本身</li></ul> <h3 id="获取样式"><a href="#获取样式" class="header-anchor">#</a> 获取样式</h3> <ul><li>使用 getComputedStyle 获取元素计算后的样式，不要通过 node.style.属性获取</li></ul> <h3 id="js-事件"><a href="#js-事件" class="header-anchor">#</a> JS 事件</h3> <ul><li>事件是在编程时系统内发生的动作或者发生的事情（单击，双击，鼠标放置，表单内容发生变化，拖拽，页面滚动等等）</li></ul> <h2 id="dom-事件流"><a href="#dom-事件流" class="header-anchor">#</a> DOM 事件流</h2> <ul><li>三个阶段： 事件捕获阶段，处于目标阶段（可以假装不存在），事件冒泡阶段</li> <li>addEventListern('type',()=&gt;{},true（发生在哪个阶段）)true 发生在捕获阶段调用 listener ，false 发生在冒泡阶段（默认）</li> <li>第三个参数有两种用法，options{once 是否仅监听一次: true ||false, capture 是否捕获阶段监听:true || false, passive 是否忽略 preventDefault :true||false } 和 useCapture(true || false)</li> <li>阻止事件传播： e.stopPropagation()</li> <li>阻止默认事件： e.preventDefault() 比如 a 链接自动跳转或者 form 表单 input type = submit</li></ul> <h2 id="事件代理"><a href="#事件代理" class="header-anchor">#</a> 事件代理</h2> <ul><li>事件绑定代理给都元素，由父元素根据事件来源统一处理</li> <li>实际上是事件冒泡的应用</li></ul> <h3 id="bom-浏览器对象模型"><a href="#bom-浏览器对象模型" class="header-anchor">#</a> BOM 浏览器对象模型</h3> <ul><li>window 对象： var 声明的变量，或者 function fn（）声明，都是 window 的属性</li> <li>navigator 对象：浏览器相关的信息 navigator.userAgent</li> <li>screen 屏幕相关信息</li> <li>offsetHeight 页面文档的高度 screen.height 屏幕高度</li> <li>clientHeight 视窗高度 等价于 window.innerHeight</li> <li>window.scrollY || document.documentElement.scrollTop 当前页面滚动了多少</li> <li>element.offsetParent 距离最近的是定位元素的祖先元素</li> <li>element.offsetTop 到距离最近的是定位元素的祖先元素的距离</li> <li>element.getBoundingClientRect()在当前窗口占据多少</li> <li>element.getBoundingClientRect().top + document.body.scrollTop 元素距离页面顶部的距离</li> <li>const isShow = node =&gt; node.getBoundingClientRect().top &lt; window.innerHeight &amp;&amp; node.getBoundingClientRect().top &gt; 0</li></ul> <h2 id="检测设备"><a href="#检测设备" class="header-anchor">#</a> 检测设备</h2> <p>const isAndroid = () =&gt; /android/i.test(navigator.userAgent)
const isIPhone = () =&gt; /iphone/i.test(navigator.userAgent)
const isIOS = () =&gt; /iphone|ipad/i.test(navigator.userAgent)</p> <h2 id="滚动"><a href="#滚动" class="header-anchor">#</a> 滚动</h2> <ul><li>scrollTo({top:100, left:0,behavior:'smooth'})滚动到哪里</li> <li>scrollBy({top:window.innerHeight, left:0,behavior:'smooth'})平滑滚动多少</li> <li>decodeURI()</li> <li>decodeURIComponent()</li> <li>encodeURI() 不会对 : / ? &amp; = # 编码</li> <li>encodeURIComponent() 会对 : / ? &amp; = # 编码</li></ul> <h2 id="cookie-seesion"><a href="#cookie-seesion" class="header-anchor">#</a> cookie seesion</h2> <ul><li>cookie 最大容量 4k 记录某些页面关闭或者刷新后仍然需要记录的信息； cookie 每次发送请求时都会在请求头中。（常规后端设置，但是前端设置也可以）</li></ul> <h3 id="如何与后端交互"><a href="#如何与后端交互" class="header-anchor">#</a> 如何与后端交互</h3> <ul><li>Form 表单提交： 只有 get 和 post || 有问无答，体验不佳</li> <li>AJAX 支持 XMLHttpRequest || Fetch</li> <li>WebSocket 可以由服务器端主动发起</li> <li>Object.entries () 返回一个数组，其元素是与直接在 object 上找到的可枚举属性键值对相对应的数组。</li> <li>轮询：每隔固定时间发一次请求</li> <li>长轮询：客户端发请求等待响应，当响应时再次发请求。 服务器端，请求到来，如果没新数据，则不发，当有新数据通知客户端，再响应</li></ul> <h3 id="回调-异步"><a href="#回调-异步" class="header-anchor">#</a> 回调&amp;异步</h3> <ul><li><p>回调：传一个函数进去。如果多层回调就会带来回调地狱的问题</p></li> <li><p>Promise 三个状态：pending | fulfilled | rejected</p></li> <li><p>Promise.all 把全部 resolve 的结果放进一个数组</p></li> <li><p>Promise.race 得到一个最先 resolve 的结果</p></li> <li><p>await 需要在 Promise 对象之前</p></li> <li><p>await 只在 async 函数内有效</p> <p>1.Promise 只能由 Pending 转化为 fulfilled 或者 rejected，fulfilled 与 rejected 不能相互转化
2.Promise 中的 then 不添加第二个参数，这时候就会执行 catch 里面的代码
3.Promise 的链式结构(但是有个重点是&quot;promise 执行完毕后返回的 promise 默认进入 fulfilled 状态&quot;，所以执行完毕后默认执行链式结构中的 resolve 回调。执行进入失败状态后，链式结构也会执行之后的 resolve 回调。)
4.then 里面的 resolve 报错，catch 是可以捕获报错信息，then 的第二个参数不能捕获
5.Promise 里面执行的代码可以被 then 的第二个参数捕获到,并且不会进入到 resolve，而是直接进入 reject(没有执行 resolve 代码，直接进入了 reject | 就算没有 reject 回调，还是会进入 reject 回调 | 如果不存在 then 的第二个回调，则会进入 catch)</p></li></ul> <h3 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h3> <ul><li>同源：同协议 | 同域名 | 同端口</li> <li>同源策略的初衷：ip，数据，知识产权的保护</li> <li>是服务器拒绝还是浏览器拒绝？： 用户浏览器拒绝（不是不发请求，而是拦截响应，不展示数据）</li> <li>如果想跨域请求第三方接口，或者把自己的接口提供给第三方要怎么做？：JSONP | CORS | 服务器中转</li></ul> <h2 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h2> <ul><li>原理： 同源策略只限制 ajax 请求，不限制 script 标签加载 js。可以通过 script 标签请求资源，并提前写好接收函数</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;script&gt;
function handleData(data) {
console.log(data)
}
&lt;/script&gt;
&lt;script src=“http://api.jirengu.com/getWeather.php?callback=handleData”&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>浏览器会发送一个带参数的请求，服务器在收到请求后，从 callback 参数得到 handleData，然后将数据加到这个 handleData 中，假设是 handleData({data:1})，script 里的资源加载后会当成 js 执行，相当于执行 handleData({data:1})，即可在预定义的 handleData 函数里处理数据</li></ul> <h2 id="cors-跨域资源共享"><a href="#cors-跨域资源共享" class="header-anchor">#</a> CORS 跨域资源共享</h2> <ul><li>原理：在发送 ajax 请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin。 后台收到请求后，如果确定接受请求则会再返回结果中加入一个响应头： Access-Control-Allow-Origin。 浏览器判断该响应头中是否包含当前 Origin 的值，如果有则会处理响应，我们就可以拿到响应数据，如果没有浏览器直接驳回</li></ul> <h2 id="服务器代理"><a href="#服务器代理" class="header-anchor">#</a> 服务器代理</h2> <ul><li>通过利用服务器转发请求来获取数据，不建议</li></ul> <h3 id="withcredentials"><a href="#withcredentials" class="header-anchor">#</a> withCredentials：</h3> <ul><li>XMLHttpRequest 的一个属性，表示跨域请求是否提供类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书。（同源无效）</li> <li>Access-Control-Allow-Credentials: true -&gt;服务器设置</li> <li>xhr.withCredentials = true; 前端设置</li></ul> <h3 id="samesite"><a href="#samesite" class="header-anchor">#</a> sameSite</h3> <ul><li>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。</li> <li>Cookie 的 SameSite 属性用来限制第三方 Cookie，从而减少安全风险。</li></ul> <h3 id="httponly"><a href="#httponly" class="header-anchor">#</a> httponly</h3> <ul><li>如果 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击，窃取 cookie 内容，这样就增加了 cookie 的安全性，即便是这样，也不要将重要信息存入 cookie。</li></ul> <h3 id="nodejs-npm-yarn-commonjs"><a href="#nodejs-npm-yarn-commonjs" class="header-anchor">#</a> nodejs npm yarn commonJS</h3> <ul><li>nodejs 基于 chrome v8 引擎的 JavaScript 运行环境</li> <li>LTS current 区别在于 前者是长期支持的，后者是最新版</li> <li>nodejs 是 IO 密集型（网络，磁盘读写）</li> <li>当使用 require 时，会先从该文件夹的/node-modules 寻找，再去上一层，直到/</li> <li>package.json 中的 bin 文件就是 cli 指令</li> <li>depencies 自己项目运行依赖的模块 --save</li> <li>devDependencies 其他的依赖模块 --save-dev</li> <li>script npm 中的可执行的 bash 指令</li> <li>npx 从文件夹内去找这个指令</li></ul> <h3 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h3> <ul><li>依赖管理</li> <li>命名冲突</li> <li>代码可读性</li> <li>代码复用性</li></ul> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h3> <h3 id="entry"><a href="#entry" class="header-anchor">#</a> entry</h3> <ul><li>假如希望有多个文件，就可以写这里</li> <li>入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</li></ul> <h4 id="loaders"><a href="#loaders" class="header-anchor">#</a> Loaders</h4> <ul><li>webpack 只能理解 js 和 json 文件，loader 让 webpack 能去处理其他类型的文件，并将它们转换成有效的模块，以供程序使用，以及被添加到依赖图中</li> <li>loader 的两个属性： test（识别出哪个文件会被转换） use（定义在进行转换时，应该使用哪个 loader）</li> <li>style-loader 把 CSS 插入到 DOM 中。</li> <li>css-loader css-loader 会对@import 和 url()进行处理，就像 js 解析 import/require()一样。</li></ul> <h4 id="plugins"><a href="#plugins" class="header-anchor">#</a> plugins</h4> <ul><li>插件用于执行范围更广的任务。比如：打包优化，资源管理，注入环境变量等（目的在于解决 loader 无法实现的其他的事情）</li> <li>CleanWebpackPlugin 构建前清理/dist 文件夹。（现在推荐 output.clean 配置而不是插件）</li> <li>HtmlWebpackPlugin 为应用程序生成一个 HTML 文件，并自动注入所有生成的 bundle。</li></ul> <h4 id="sourcemap"><a href="#sourcemap" class="header-anchor">#</a> sourcemap</h4> <ul><li>在编译后的代码和源码进行一个 mapping</li></ul> <h4 id="devtool"><a href="#devtool" class="header-anchor">#</a> devtool</h4> <ul><li>此选项控制是否生成，以及如何生成 source map。</li></ul> <h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="header-anchor">#</a> webpack-dev-server</h4> <ul><li>提供了一个基本的 web server，并且具有 live reloading(实时重新加载) 功能</li></ul> <h4 id="mhr"><a href="#mhr" class="header-anchor">#</a> MHR</h4> <ul><li>模块热替换，开发过程中，可以让某个模块保持状态，但是模块产生更新</li> <li>它允许在运行时更新所有类型的模块，而无需完全刷新。</li></ul> <h4 id="compiler-compilation"><a href="#compiler-compilation" class="header-anchor">#</a> compiler | compilation</h4> <ul><li>compiler 对象代表一个完全配置的 webpack 环境</li> <li>compilation 对象代表对版本资源的单次构建</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-progress-track/assets/js/app.7ad0e47c.js" defer></script><script src="/front-end-progress-track/assets/js/2.41268747.js" defer></script><script src="/front-end-progress-track/assets/js/12.e9fe9892.js" defer></script>
  </body>
</html>
