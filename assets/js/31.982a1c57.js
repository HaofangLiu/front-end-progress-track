(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{358:function(n,t,i){"use strict";i.r(t);var e=i(27),h=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[n._v("#")]),n._v(" 算法")]),n._v(" "),t("h2",{attrs:{id:"时间复杂度与空间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度与空间复杂度"}},[n._v("#")]),n._v(" 时间复杂度与空间复杂度")]),n._v(" "),t("p",[n._v("大O表示法： 一种度量来计算算法的效率， 一般来说按最复杂的情况来判断它的量级")]),n._v(" "),t("h3",{attrs:{id:"时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[n._v("#")]),n._v(" 时间复杂度")]),n._v(" "),t("p",[n._v("我们用时间复杂度衡量算法的性能是否高效")]),n._v(" "),t("p",[n._v("通过一下步骤来计算时间复杂度")]),n._v(" "),t("ul",[t("li",[n._v("计算程序中每条语句的执行次数， 并相加， 得到语句的总执行次数， 即语句频度或时间频度， 记为T(n)")]),n._v(" "),t("li",[n._v("用常数1取代T(n)中的所有加法常数")]),n._v(" "),t("li",[n._v("只保留T(n)中的最高阶项")]),n._v(" "),t("li",[n._v("如果最高阶项存在且不是1， 则去除与这个项相乘的常数")])]),n._v(" "),t("p",[n._v("常见的时间复杂度")]),n._v(" "),t("ul",[t("li",[n._v("O(1) 常数阶")]),n._v(" "),t("li",[n._v("O(logn) 对数阶")]),n._v(" "),t("li",[n._v("O(n) 线性阶")]),n._v(" "),t("li",[n._v("O(nlogn) 线性对数阶")]),n._v(" "),t("li",[n._v("O(n^2) 平方阶")]),n._v(" "),t("li",[n._v("O(n^3) 立方阶")]),n._v(" "),t("li",[n._v("O(2^n) 指数阶")]),n._v(" "),t("li",[n._v("O(n!) 阶乘阶")])]),n._v(" "),t("p",[n._v("按照时间复杂度从小到大的顺序排列\nO(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)")]),n._v(" "),t("p",[n._v("933 最近请求次数  队列\n349 两个数组的交集 SET\n237 删除链表中的节点 链表没有prev 考虑从given node 入手\n206 反转链表 引入null节点\n144 二叉树的前序遍历 递归\n141 环形链表 双指针\n83 删除排序链表中的重复元素 暴力\n20 有效的括号 map + stack\n76 最小覆盖子串 滑窗+map\n3 无重复字符的最长子串 map\n1 两数之和 map\n104 二叉树的最大深度 dfs\n102 二叉树的层次遍历 bfs\n94 二叉树的中序遍历  递归或者栈\n112 路径总和 I bfs\n112 路径总和 II bfs\n215 数组中的第K个最大元素 最小堆")]),n._v(" "),t("p",[n._v("深度优先遍历dfs：尽可能深的搜索树的分支 （根->children->根->children...）\n广度优先遍历bfs：尽可能广的搜索树的分支  利用队列(根压入队列 -> 队头出队并访问 -> 队头的children压入队列 -> 队头的children出队并访问 -> 队头的children的children压入队列 -> 队头的children的children出队并访问...)")]),n._v(" "),t("p",[n._v("js堆\n用数组广度优先遍历排列所有节点\n左侧节点位置是2n+1\n右侧节点位置是2n+2\n父节点位置是Math.floor((n-1)/2)")]),n._v(" "),t("p",[n._v("最小堆\nclass MinHeap {\nconstructor() {\nthis.heap = [];\n}\nsize() {\nreturn this.heap.length;\n}\npeek() {\nreturn this.heap[0];\n}\nswap(i1, i2) {\nconst temp = this.heap[i1];\nthis.heap[i1] = this.heap[i2]\nthis.heap[i2] = temp\n}\ngetParent(index) {\nreturn Math.floor((index - 1) / 2)\n}\nshiftUp(index) {\nif (index === 0) return\nconst parentIndex = this.getParent(index);\nif (this.heap[parentIndex] > this.heap[index]) {\nthis.swap(parentIndex, index)\nthis.shiftUp(parentIndex)\n}\n}\ninsert(val) {\nthis.heap.push(val);\nthis.shiftUp(this.heap.length - 1)\n}\ngetLeft(index) {\nreturn index * 2 + 1\n}\ngetRight(index) {\nreturn index * 2 + 2\n}\nshiftDown(index) {\nconst left = this.getLeft(index);\nconst right = this.getRight(index);\nif (this.heap[index] > this.heap[left]) {\nthis.swap(index, left);\nthis.shiftDown(left)\n}\nif (this.heap[index] > this.heap[right]) {\nthis.swap(index, right);\nthis.shiftDown(right)\n}\n}\nremoveTop() {\nthis.heap[0] = this.heap.pop();\nthis.shiftDown(0)\n}\n}\n最大堆")])])}),[],!1,null,null,null);t.default=h.exports}}]);